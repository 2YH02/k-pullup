# AGENTS.md

이 문서는 이 저장소에서 작업하는 코딩 에이전트를 위한 실행 규칙입니다.

## 1) 목표와 원칙

- 목표: 기능 추가보다 먼저 안정성, 일관성, 회귀 방지를 우선한다.
- 원칙:
  - 작은 변경으로 끝까지 동작 확인한다.
  - 변경 이유가 없는 리팩터링은 하지 않는다.
  - 기존 UI/흐름을 임의로 바꾸지 않는다.

## 2) 프로젝트 기본 정보

- 프레임워크: Next.js 14 (App Router), TypeScript, Tailwind
- 상태관리: Zustand (`/store`)
- 패키지 매니저: Yarn Berry (`yarn@4`)
- 지도: Kakao Maps SDK

주요 실행 명령어:

```bash
yarn dev:simple
yarn lint
yarn build
yarn test:e2e
```

## 3) 작업 전 체크

- 관련 파일을 먼저 읽고 기존 패턴을 따른다.
- 변경 범위가 API, 지도, 인증, 상태관리이면 영향 파일을 함께 확인한다.
- 새 규칙이 필요하면 이 문서에 짧게 추가한다.

## 4) API 호출 규칙 (중요)

- 기본 원칙: 가능한 한 `"/api/v1/*"` 경로를 사용한다.
  - `next.config.mjs` rewrite를 통해 백엔드로 전달된다.
- 서버 컴포넌트/서버 실행 컨텍스트에서만 필요한 경우에 한해 `NEXT_PUBLIC_BASE_URL` 직접 사용을 허용한다.
- 한 기능 내부에서 rewrite 방식과 direct base URL 방식을 혼용하지 않는다.
- 모든 API 함수는 `lib/fetchData.ts`를 우선 사용하고, 실패 케이스(`!response.ok`)를 명시적으로 처리한다.

## 5) fetchData 규칙 (중요)

- `lib/fetchData.ts`는 서버/클라이언트 공용이다.
- 브라우저 전용 API(`alert`, `window`, `localStorage`)는 직접 호출하지 않는다.
- 공통 에러 처리는 "throw + 호출부 처리" 또는 "일관된 에러 객체 반환" 중 하나로 통일한다.

## 6) Zustand 상태관리 규칙

- store setter는 의도를 명확히 구분한다.
  - append용 setter
  - replace/reset용 setter
- 지도 마커/오버레이처럼 반복 렌더링되는 데이터는 반드시 clear/reset 경로를 포함한다.
- `any` 사용을 피하고 최소한의 타입 별칭이라도 정의한다.

## 7) React Hook 규칙

- `useEffect`, `useMemo`, `useCallback`의 dependency를 임의로 생략하지 않는다.
- ESLint 경고를 없애기 위해 주석으로 룰을 끄기보다, 함수 안정화(`useCallback`)나 로직 분리로 해결한다.
- mount-only effect가 필요하면 그 이유를 짧게 주석으로 남긴다.

## 8) Kakao Map 관련 규칙

- 이벤트 등록 시 반드시 cleanup에서 제거한다.
- map/marker/overlay 인스턴스는 store와 실제 지도 상태가 불일치하지 않게 관리한다.
- 대량 재로딩 로직에서는 성능(중복 생성, 메모리 누수)을 먼저 점검한다.

## 9) UI/성능 규칙

- 가능한 경우 Next `Image`를 사용한다.
- 정당한 이유 없이 `img`를 추가하지 않는다.
- LCP 영향을 주는 변경은 최소 1회 `yarn build`로 확인한다.

## 10) 검증 규칙

- 코드 변경 후 기본 검증:
  1. `yarn lint`
  2. 영향 큰 변경이면 `yarn build`
  3. 사용자 플로우 변경이면 관련 e2e 1개 이상 실행
- 실행하지 못한 검증이 있으면 PR/결과 메시지에 명시한다.

## 11) 변경 범위 규칙

- 요청과 무관한 파일은 수정하지 않는다.
- 대규모 포맷 변경/정렬 변경은 피한다.
- TODO는 "무엇을, 왜, 언제"가 드러나게 구체적으로 남긴다.
- 단, 사용자가 "스타일링 개선/리팩터링"을 명시적으로 요청한 경우에는 현재 디자인 토큰/스타일 규칙에 맞는 범위에서 관련 UI 파일을 넓게 수정할 수 있다.
  - 이 경우에도 기능/플로우/데이터 동작은 바꾸지 않고 시각적 일관성 개선에만 집중한다.
  - 하드코딩 색상 추가보다 토큰 재사용/토큰 추가를 우선한다.

## 12) 권장 작업 순서

1. 맥락 파악 (`app`, `components`, `lib/api`, `store`)
2. 최소 수정 구현
3. 로컬 검증
4. 변경 요약 + 리스크/후속 작업 정리

## 13) 커밋/로그 규칙

- 커밋 메시지는 기본적으로 한국어로 작성한다.
- 커밋 메시지는 `type: 요약` 형식을 사용하고, 접두사는 `feat`, `fix`, `refactor`, `style`, `chore`, `docs`, `test`를 기본으로 사용한다.
- 커밋 제목은 두괄식으로 작성해 변경 결과/핵심을 첫 문구에 바로 드러낸다.
- 커밋 전 `git status`와 `git diff --stat`로 변경 범위를 확인한다.
- 검증 명령(`yarn lint`, `yarn build`, 필요 시 `yarn test:e2e`) 실행 후 로그를 확인한다.
- 경고/실패가 남아 있으면 커밋 메시지 또는 결과 보고에 명시한다.

## 14) PR 작성 규칙

- PR 생성 요청을 받으면 에이전트가 제목/본문 초안을 먼저 제안한다.
- PR 본문은 `.github/pull_request_template.md` 형식을 기본으로 따른다.
- 본문에 최소한 다음 내용을 포함한다:
  - 개요
  - 주요 변경사항
  - 영향 범위/리스크
  - 검증 결과(`lint/build/test`)와 미실행 항목

## 15) 모바일 상호작용 규칙

- hover 효과는 보조로만 사용하고, 기본 상태만으로도 UI 완성도를 유지한다.
- 터치 환경을 위해 `active` 피드백을 반드시 함께 제공한다. (예: scale, border/background 변화)
- 키보드 접근성을 위해 `focus-visible` 스타일을 함께 제공한다.
- 모바일(`mo:`)에서는 hover 의존 애니메이션을 줄이거나 제거하고, 터치 제스처/active 중심으로 설계한다.

## 16) 스타일링 일관성 규칙

- 스타일링 요청(리팩터링/개선)은 기본 방향을 "모던, 심플, 깔끔"으로 유지한다.
- 홈/공용 UI는 현재 프로젝트 톤(웜 뉴트럴 + 저채도 포인트)에 맞춰 일관되게 적용한다.
- 색상은 하드코딩하지 않고 `app/globals.css`의 디자인 토큰을 우선 사용한다.
- 필요한 색상이 없으면 토큰을 먼저 추가하고, 의미 기반 이름(역할/컴포넌트 목적)을 사용한다.
- 동일 역할의 스타일은 컴포넌트마다 임의로 다르게 만들지 말고, 기존 패턴(보더 강도/라운드/간격/텍스트 톤)을 재사용한다.
- 시각 효과는 과한 그림자/강한 그라디언트보다 보더, 배경 톤 변화, 미세 모션 중심으로 설계한다.

## 17) 아이콘 일관성 규칙

- 동일한 내비게이션/동일한 기능군에서는 아이콘 라이브러리를 혼용하지 않는다. (가능하면 한 화면에서 단일 세트 사용)
- 아이콘 스타일(라인/필, 코너 성격, 두께)을 화면 단위로 통일한다.
- 기본/활성 상태의 차이는 색상과 두께 변화 중심으로 표현하고, 아이콘 모양 자체는 임의 변경하지 않는다.
- 아이콘 색상도 하드코딩하지 않고 토큰 기반(`text-*`, `fill-*`, `stroke-*`)으로 적용한다.
- 크기 체계는 작은/기본/강조(예: 18/20/24)처럼 제한된 스케일만 사용해 시각 리듬을 맞춘다.

## 18) 마이크로애니메이션 규칙

- 마이크로애니메이션은 장식보다 상태 피드백(클릭 가능, 선택됨, 전환 중) 전달 목적을 우선한다.
- 기본 강도는 미세하게 유지한다. (`scale` 약 `0.98~1.02`, `translate` 약 `1~2px`)
- 기본 타이밍은 `120~220ms` 범위에서 통일하고, easing도 화면 단위로 일관되게 사용한다.
- 성능을 위해 `transform`, `opacity` 중심으로 구현하고, 레이아웃 변경을 유발하는 애니메이션은 지양한다.
- 모바일(`mo:`)에서는 hover 의존 애니메이션을 최소화하고 `active`, `focus-visible` 피드백을 우선한다.
- 접근성을 위해 `prefers-reduced-motion` 환경에서는 애니메이션을 축소하거나 비활성화한다.
