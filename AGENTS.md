# AGENTS.md

이 문서는 이 저장소에서 작업하는 코딩 에이전트를 위한 실행 규칙입니다.

## 1) 목표와 원칙

- 목표: 기능 추가보다 먼저 안정성, 일관성, 회귀 방지를 우선한다.
- 원칙:
  - 작은 변경으로 끝까지 동작 확인한다.
  - 변경 이유가 없는 리팩터링은 하지 않는다.
  - 기존 UI/흐름을 임의로 바꾸지 않는다.

## 2) 프로젝트 기본 정보

- 프레임워크: Next.js 14 (App Router), TypeScript, Tailwind
- 상태관리: Zustand (`/store`)
- 패키지 매니저: Yarn Berry (`yarn@4`)
- 지도: Kakao Maps SDK

주요 실행 명령어:

```bash
yarn dev:simple
yarn lint
yarn build
yarn test:e2e
```

## 3) 작업 전 체크

- 관련 파일을 먼저 읽고 기존 패턴을 따른다.
- 변경 범위가 API, 지도, 인증, 상태관리이면 영향 파일을 함께 확인한다.
- 새 규칙이 필요하면 이 문서에 짧게 추가한다.

## 4) API 호출 규칙 (중요)

- 기본 원칙: 가능한 한 `"/api/v1/*"` 경로를 사용한다.
  - `next.config.mjs` rewrite를 통해 백엔드로 전달된다.
- 서버 컴포넌트/서버 실행 컨텍스트에서만 필요한 경우에 한해 `NEXT_PUBLIC_BASE_URL` 직접 사용을 허용한다.
- 한 기능 내부에서 rewrite 방식과 direct base URL 방식을 혼용하지 않는다.
- 모든 API 함수는 `lib/fetchData.ts`를 우선 사용하고, 실패 케이스(`!response.ok`)를 명시적으로 처리한다.

## 5) fetchData 규칙 (중요)

- `lib/fetchData.ts`는 서버/클라이언트 공용이다.
- 브라우저 전용 API(`alert`, `window`, `localStorage`)는 직접 호출하지 않는다.
- 공통 에러 처리는 "throw + 호출부 처리" 또는 "일관된 에러 객체 반환" 중 하나로 통일한다.

## 6) Zustand 상태관리 규칙

- store setter는 의도를 명확히 구분한다.
  - append용 setter
  - replace/reset용 setter
- 지도 마커/오버레이처럼 반복 렌더링되는 데이터는 반드시 clear/reset 경로를 포함한다.
- `any` 사용을 피하고 최소한의 타입 별칭이라도 정의한다.

## 7) React Hook 규칙

- `useEffect`, `useMemo`, `useCallback`의 dependency를 임의로 생략하지 않는다.
- ESLint 경고를 없애기 위해 주석으로 룰을 끄기보다, 함수 안정화(`useCallback`)나 로직 분리로 해결한다.
- mount-only effect가 필요하면 그 이유를 짧게 주석으로 남긴다.

## 8) Kakao Map 관련 규칙

- 이벤트 등록 시 반드시 cleanup에서 제거한다.
- map/marker/overlay 인스턴스는 store와 실제 지도 상태가 불일치하지 않게 관리한다.
- 대량 재로딩 로직에서는 성능(중복 생성, 메모리 누수)을 먼저 점검한다.

## 9) UI/성능 규칙

- 가능한 경우 Next `Image`를 사용한다.
- 정당한 이유 없이 `img`를 추가하지 않는다.
- LCP 영향을 주는 변경은 최소 1회 `yarn build`로 확인한다.

## 10) 검증 규칙

- 코드 변경 후 기본 검증:
  1. `yarn lint`
  2. 영향 큰 변경이면 `yarn build`
  3. 사용자 플로우 변경이면 관련 e2e 1개 이상 실행
- 실행하지 못한 검증이 있으면 PR/결과 메시지에 명시한다.

## 11) 변경 범위 규칙

- 요청과 무관한 파일은 수정하지 않는다.
- 대규모 포맷 변경/정렬 변경은 피한다.
- TODO는 "무엇을, 왜, 언제"가 드러나게 구체적으로 남긴다.
- 단, 사용자가 "스타일링 개선/리팩터링"을 명시적으로 요청한 경우에는 현재 디자인 토큰/스타일 규칙에 맞는 범위에서 관련 UI 파일을 넓게 수정할 수 있다.
  - 이 경우에도 기능/플로우/데이터 동작은 바꾸지 않고 시각적 일관성 개선에만 집중한다.
  - 하드코딩 색상 추가보다 토큰 재사용/토큰 추가를 우선한다.

## 12) 권장 작업 순서

1. 맥락 파악 (`app`, `components`, `lib/api`, `store`)
2. 최소 수정 구현
3. 로컬 검증
4. 변경 요약 + 리스크/후속 작업 정리

## 13) 커밋/로그 규칙

- 커밋 메시지는 기본적으로 한국어로 작성한다.
- 커밋 메시지는 `type: 요약` 형식을 사용하고, 접두사는 `feat`, `fix`, `refactor`, `style`, `chore`, `docs`, `test`를 기본으로 사용한다.
- 커밋 제목은 두괄식으로 작성해 변경 결과/핵심을 첫 문구에 바로 드러낸다.
- 커밋 전 `git status`와 `git diff --stat`로 변경 범위를 확인한다.
- 검증 명령(`yarn lint`, `yarn build`, 필요 시 `yarn test:e2e`) 실행 후 로그를 확인한다.
- 경고/실패가 남아 있으면 커밋 메시지 또는 결과 보고에 명시한다.

## 14) PR 작성 규칙

- PR 생성 요청을 받으면 에이전트가 제목/본문 초안을 먼저 제안한다.
- PR 본문은 `.github/pull_request_template.md` 형식을 기본으로 따른다.
- 본문에 최소한 다음 내용을 포함한다:
  - 개요
  - 주요 변경사항
  - 영향 범위/리스크
  - 검증 결과(`lint/build/test`)와 미실행 항목

## 15) 모바일 상호작용 규칙

- hover 효과는 보조로만 사용하고, 기본 상태만으로도 UI 완성도를 유지한다.
- 터치 환경을 위해 `active` 피드백을 반드시 함께 제공한다. (예: scale, border/background 변화)
- 키보드 접근성을 위해 `focus-visible` 스타일을 함께 제공한다.
- 모바일(`mo:`)에서는 hover 의존 애니메이션을 줄이거나 제거하고, 터치 제스처/active 중심으로 설계한다.

## 16) 스타일링 일관성 규칙

- 스타일링 요청(리팩터링/개선)은 기본 방향을 "모던, 심플, 깔끔"으로 유지한다.
- 홈/공용 UI는 현재 프로젝트 톤(웜 뉴트럴 + 저채도 포인트)에 맞춰 일관되게 적용한다.
- 색상은 하드코딩하지 않고 `app/globals.css`의 디자인 토큰을 우선 사용한다.
- 필요한 색상이 없으면 토큰을 먼저 추가하고, 의미 기반 이름(역할/컴포넌트 목적)을 사용한다.
- 동일 역할의 스타일은 컴포넌트마다 임의로 다르게 만들지 말고, 기존 패턴(보더 강도/라운드/간격/텍스트 톤)을 재사용한다.
- 마이페이지 리스트 카드 기본 배경은 `bg-search-input-bg/50`(다크: `dark:bg-black/35`)를 우선 사용하고, 강조 목적이 아닌 일반 카드에서 `bg-white/*` 사용은 지양한다.
- 시각 효과는 과한 그림자/강한 그라디언트보다 보더, 배경 톤 변화, 미세 모션 중심으로 설계한다.

## 17) 아이콘 일관성 규칙

- 동일한 내비게이션/동일한 기능군에서는 아이콘 라이브러리를 혼용하지 않는다. (가능하면 한 화면에서 단일 세트 사용)
- 아이콘 스타일(라인/필, 코너 성격, 두께)을 화면 단위로 통일한다.
- 기본/활성 상태의 차이는 색상과 두께 변화 중심으로 표현하고, 아이콘 모양 자체는 임의 변경하지 않는다.
- 아이콘 색상도 하드코딩하지 않고 토큰 기반(`text-*`, `fill-*`, `stroke-*`)으로 적용한다.
- 크기 체계는 작은/기본/강조(예: 18/20/24)처럼 제한된 스케일만 사용해 시각 리듬을 맞춘다.

## 18) 마이크로애니메이션 규칙

- 마이크로애니메이션은 장식보다 상태 피드백(클릭 가능, 선택됨, 전환 중) 전달 목적을 우선한다.
- 기본 강도는 미세하게 유지한다. (`scale` 약 `0.98~1.02`, `translate` 약 `1~2px`)
- 기본 타이밍은 `120~220ms` 범위에서 통일하고, easing도 화면 단위로 일관되게 사용한다.
- 성능을 위해 `transform`, `opacity` 중심으로 구현하고, 레이아웃 변경을 유발하는 애니메이션은 지양한다.
- 모바일(`mo:`)에서는 hover 의존 애니메이션을 최소화하고 `active`, `focus-visible` 피드백을 우선한다.
- 접근성을 위해 `prefers-reduced-motion` 환경에서는 애니메이션을 축소하거나 비활성화한다.

## 19) 로딩 UI 규칙

- 페이지 진입/데이터 페칭 로딩은 기본적으로 스켈레톤 UI를 사용한다.
- 스켈레톤은 실제 렌더링될 레이아웃(헤더/섹션/카드/리스트)과 최대한 같은 구조와 간격으로 구성한다.
- 로딩 스피너는 정말 필요한 경우에만 사용한다. (예: 레이아웃을 표현하기 어려운 매우 짧은 비동기 작업, 작은 버튼 단위 처리)
- 전체 페이지 로딩에서 스피너만 단독으로 노출하는 방식은 지양하고, 가능한 한 스켈레톤 + 최소 텍스트 안내를 우선한다.

## 20) 페이지 전환 애니메이션 규칙

- Next.js App Router + SSR 환경에서도 페이지 전환 애니메이션은 허용한다. 단, SEO/초기 렌더에 영향을 주지 않도록 SSR 콘텐츠 노출을 지연하지 않는다.
- 전환 애니메이션은 레이아웃 프레임(예: `SideMain`, 헤더, 하단 네비) 전체가 아니라 "내부 콘텐츠 영역"에만 적용한다.
- 기본 효과는 미세한 `opacity + transform(translate)` 중심으로 유지하고, 기본 타이밍은 `120~220ms` 범위에서 사용한다.
- 페이지 전환 구현 시 `prefers-reduced-motion` 대응을 반드시 포함한다.
- 전환 애니메이션 적용/수정 시 최소 `yarn lint`를 실행하고, LCP 영향이 우려되는 변경이면 `yarn build` 결과를 함께 확인한다.

## 21) 컴포넌트 분리/폴더 구조 규칙

- 기본 원칙: 재사용성과 책임 분리를 위해 분리하되, 한 번만 쓰는 단순 마크업은 과분리하지 않는다.
- 분리 기준:
  - JSX 블록이 길어져(대략 40~60줄 이상) 읽기 어려우면 하위 컴포넌트로 분리한다.
  - 독립 상태/이벤트 로직(`useState`, `useEffect`, 핸들러 묶음)이 생기면 분리 우선 검토한다.
  - 동일 UI 패턴이 2곳 이상에서 반복되면 공용 컴포넌트 추출을 우선한다.
  - API 호출/스토어 접근/지도 객체 제어가 섞일 때는 UI와 로직 경계를 나눈다.
- 폴더 책임:
  - `app/*`: 라우트 진입 파일(`page.tsx`, `layout.tsx`)과 서버 데이터 조합 중심. 화면 세부 UI는 직접 과도하게 담지 않는다.
  - `components/pages/*`: 특정 페이지 전용 UI 조각(해당 페이지에서만 의미가 있는 블록).
  - `components/common/*`: 여러 페이지에서 재사용되는 프리미티브/공용 블록.
  - `components/layout/*`: 네비, 헤더, 프레임 등 레이아웃 구조 컴포넌트.
  - `components/icons/*`: 아이콘 컴포넌트. 동일 화면에서는 아이콘 스타일 세트 일관성을 유지한다.
  - `lib/*`: 프레임워크 비의존 유틸/헬퍼 및 공통 로직.
  - `lib/api/*`: API 호출 함수. `fetchData` 규칙과 에러 처리 규칙을 따른다.
  - `store/*`: Zustand store. setter 의도(append vs replace/reset)를 명확히 분리한다.
- 파일 생성/수정 규칙:
  - 새 파일을 만들기 전에 기존 `components/pages/<route>` 또는 `components/common`에 유사 컴포넌트가 있는지 먼저 확인한다.
  - 페이지 전용이면 `components/pages/<route>/`에, 2개 이상 화면에서 재사용되면 `components/common/`으로 이동/생성한다.
  - Props는 최소 단위로 명시하고 `any`를 피한다.
  - 스타일은 토큰 기반 클래스(`globals.css`)를 우선 사용하고, 하드코딩 색상 추가를 피한다.
  - 분리 후 기존 기능/흐름/접근성(`active`, `focus-visible`)이 유지되는지 `yarn lint`로 최소 검증한다.

## 22) 다크모드 스타일링 규칙

- 기본 원칙: 스타일링 수정 시 라이트 모드만 변경하지 않고, 다크 모드(`dark:`)를 항상 함께 반영한다.
- 대응 방식:
  - 텍스트/보더/배경의 대비를 라이트/다크 각각에서 읽기 가능하도록 확인한다.
  - 색상은 하드코딩 대신 토큰 기반 클래스를 우선 사용하고, 다크 값도 같은 의미 체계로 맞춘다.
  - 인터랙션 상태(`hover`, `active`, `focus-visible`, `disabled`)는 다크 모드 상태까지 포함해 작성한다.
- 구현 규칙:
  - 새 컴포넌트 생성 시 초기부터 `dark:` 클래스를 함께 작성한다. 사후 보완 방식은 지양한다.
  - 기존 스타일 리팩터링 시 변경된 모든 시각 요소(카드, 버튼, 입력창, 아이콘, 구분선)에 대해 다크 대응 유무를 점검한다.
  - 다크 모드에서 과도한 순백/순흑 대비를 피하고, 프로젝트 토큰 톤(웜 뉴트럴 + 저채도 포인트)을 유지한다.
- 검증 규칙:
  - 스타일 변경 결과 보고 시 "다크 모드 반영 여부"를 함께 명시한다.
  - 가능하면 라이트/다크 화면을 각각 확인하고, 확인이 어려우면 미확인 항목으로 명시한다.
